# Отчет по ЛР-3

### Вариант 22. (5)

#### Хетагуров Павел Иу7-35Б

### 1. Описание условия задачи

**Цель:** Цель работы - реализовать алгоритмы обработки разреженных матриц, сравнить
эффективность использования этих алгоритмов (по
времени выполнения и по требуемой памяти) со стандартными алгоритмами обработки
матриц при различном процентном заполнении матриц ненулевыми значениями
и при различных размерах матриц.
**Общее условие задачи:** Разработать программу умножения или сложения разреженных матриц.
Предусмотреть возможность ввода данных, как с клавиатуры, так и использования
заранее подготовленных данных. Матрицы хранятся и выводятся в форме трех
объектов. Для небольших матриц можно дополнительно вывести матрицу в виде
матрицы. Величина матриц - любая (допустим, 1000*1000). Сравнить эффективность
(по памяти и по времени выполнения) стандартных алгоритмов обработки матриц с
алгоритмами обработки разреженных матриц при различной степени разреженности
матриц и различной размерности матриц.

**Вариантное условие задачи:** Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов:
- вектор A содержит значения ненулевых элементов;
- вектор JA содержит номера столбцов для элементов вектора A;
- связный список IA, в элементе Nk которого находится номер компонент
в A и JA, с которых начинается описание строки Nk матрицы A.
1. Смоделировать операцию умножения вектора-строки и матрицы,
хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию умножения, применяя стандартный алгоритм работы с
матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании
этих 2-х алгоритмов при различном проценте заполнения матриц.

#### ТЗ и внешняя спецификация

**Исходные данные и результаты (типы, форматы, способ передачи, ограничения):**

**Исходные данные**:

1. Размер матрицы, кол-во ненулевых элемментов матрицы, кол-во ненулевых строк матрицы, ненулевые элементы матрицы и индекс их столбца, размер вектора-строки,  кол-во ненулевых элемментов вектора-строки ,ненулевые элементы вектора-строки и индекс их столбца.

**Способ передачи**: Ввод в консоль (стандартный поток ввода).

**Ограничения**:

1. Элементы - целые числа типа int. В моей системе -2^32 ... 2^32 - 1
2. Строки вводятся в порядке возрастания индексов.
3. Если введены некоректные данные - программа завершается досрочно.
4. Допускаются ввод элементов не в порядке следования столбцов
5. Ввод осуществлять без ведущих и заключительных пробелов
6. Вектор умножается на матрицу слева.

**Выходные данные:**
1. Таблица с результатом умножения введенных данных.
2. Информация о кол-ве сортировок

**Способ обращения к программе**: Запуск app.exe, ввод с клавиатуры.

**Описание возможных аварийных ситуаций и ошибок пользователя:**

1. Некорректный ввод.
2. Невозможность выделения памяти
3. Переполнение переменной, отвечающей за подсчет кол-ва тактов процессора при выводе информации о сравнении способов цмножения (не контролируется)

### 2.Описание внутренних структур данных

**Описание полей**

#### 4. Оценка алгоритма.

По памяти без испольщования дополнительного массива ключей: O(n), так как при добавлении новой записи, выделяется место только под неё.

По памяти при использовании дополнительного массива ключей: O(n + 0.12n) = O(n), так как для каждой новой записи необходим новый ключ, а какждый ключ равен 68 байт (против 532 для всей записи)(указано для моей машины).

[sort comparing](img/sortCompare.png)

По времени для сортировки пузырьком: O(время сравнение * число сравнений) + O(время для перемещения памяти * кол-во перемещений)

* O(N^2) + O(time(sizeof(struct)) * N^2) = O(N^2) в худшем<br>
O(N^2) + O(0) = O(N^2) в лучшем<br>
Для qsort O(Время разделения массива * кол-во разбиений)  + O(Время переноса n элементов)
* O(log(n) * n) + O(n * time(sizeof(struct))) - в худшем
* O(n * log(n)) + O(0) - в лучшем

### 3.Функциональные тесты

Так как считается, что в файле все данные корректны - ввод из файла не проверяется.

|  Исходные данные |  Выходные |  Описание теста |
| --- | --- | --- |
| **Negative** |  |  |
|  Пустая строка | Incorrect input |  Проверка ввода некорректных данных |
|  В поле birthday введена буква | Incorrect input |  Проверка ввода некорректного дня рождения |
|  В поле статус введена 2 | Incorrect input |  Некорретный статус |
|  В любое поле ввод большего чем требуется кол-ва символов | Incorrect input |  Неверная длинна поля |
|  Добавление в таблицу с 2000 записями | Max records reached. Cant add even more |  Переполнение таблицы |
|  Файл не в директории | Cant open file |  Ошибка открытия файла |
|  Попытка удаления по несуществующему полю | Records doesnt found |  Несуществующее поле |
|  Выбор пункта по сортировке или вывода при пустой таблице | Phone book is empty |  Попытка обработки пустой таблицы |
| **Positive** |  |  |
|  Сортировка отсортированной в обратном порядке таблицы |  Корректный вывод |  Проверка сортировок |
|  Ввод максимальной длинны поля |  Корректная работа |  Граничное значение длинны поля |
|  У всех абонентов одинаковые фамилии. Удаление по ней |  Корректная работа (таблица пуста) |  Удаление всех записей |
|  Сортировка таблицы из одной записи |  Таблица не изменилась |  Граничные значения для сортировки |

### Контрольные вопросы

#### **Как выделяется память под вариантную часть запись?**

Выделяется память под самую большую возможную часть записи.  Вариантная часть всегда последняя в структуре, но может быть вложенная т.е содержать вариантное поле

#### **Что будет, если в вариантную часть ввести данные, несоответствующие описанным?**

Конфликт типов. Ошибка трансляции<br>

#### **Кто должен следить за правильностью выполнения операций с вариантной частью записей?**

Программист

#### **Что представляет собой таблица ключей, зачем она нужна?**

Таблица, элементы исходной таблицы представляются в виде ключа(опорных полей и индекса в исходной таблице)<br>

Нужна для ускорение работы с БД, записи в которой слишком массивны и доступ к каждому из полей записи постоянно не требуется.

#### **В каких случаях эффективнее обрабатывать данные в самой таблице, а в каких - в таблице ключей?**

Если память, занимаемая ключом, несущественно меньше исходной, то при относительно малом количестве записей эффективней будет обрабатывать в самой таблице, так как будет существенный выйгрыш по памяти, и незначительный проигрыш по времени.<br>

В остальных случаях будет незначительный проигрыш по памяти, но существенный выигрыш по времени при обработке в таблице ключей.

#### **Какие способы сортировки предпочтительнее для обработки таблиц и почему?**

Устойчивые - из-за особенностей применения  </br><br>

Использующие наименьшее кол-во перестановок, так как записи в таблице могут занимать большой объем памяти (их перестановка долгая).<br>

Использующие наименьшее кол-во доп памяти, так как записи в таблице могут занимать большой объем памяти (потребуется слишком много доп памяти)

### Вывод

Так как время работы сортировок зависит как от кол-ва сравниваемых элементов, так и от их размера, то, как проиллюстрировано на скриншоте выше, при увеличении или памяти, или кол-ва элементов - увеличивается время.

Поэтому использование таблицы ключей рационально, так как при том же кол-ве записей уменьшается размер каждой записи и, как следствие, уменьшается время выполнения сортировки.<br>

Таким образом, при увеличении использования памяти в 1.12 раза (для хранения таблицы ключей) скорость выполнения уменьшается примерно в 4 раза.
